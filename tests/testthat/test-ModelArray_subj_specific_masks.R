# This is to test applications with subject-specific masks (e.g. volume data)
# In these applications, there could be elements with too many subjects with NaN
# (or generally, non-finite values) in .h5 file. We need to skip them and return
# NaN for these elements' stat.
# Test data was generated by this file: ModelArray_tests/testdata_ModelArray/prep_voxeldata_wNAs.Rmd
test_that("ModelArray handles subject-specific masks as expected", {
  check_as_expected <- function(df.results, expectedResults,
                                element.subset = NULL) {
    list.flag.same <- rep(FALSE, nrow(df.results))

    # for 1st column element_id:
    if (is.null(element.subset)) {
      expect_equal(
        df.results$element_id,
        0:(nrow(df.results) - 1)
      )
    } else {
      expect_equal(
        df.results$element_id,
        element.subset
      ) # otherwise, use the one specified
    }


    # for columns other than element_id:
    for (i in seq_len(nrow(df.results))) {
      the.expected.result <- expectedResults$flag_sufficient_subj[i]

      if (the.expected.result == 0) { # insufficient subjects, expecting results as NaN
        list.flag.same[i] <- df.results[i, 2:ncol(df.results)] %>%
          unlist() %>%
          is.nan() %>%
          all() # expect: TRUE
      } else if (the.expected.result == 1) {
        list.flag.same[i] <- !(df.results[i, 2:ncol(df.results)] %>% unlist() %>% is.nan()) %>% all() # expect: TRUE
      }
    }

    list.flag.same
  }



  df.config <- data.frame(
    nsubj = c(60, 40, 30),
    specials = c("", "", "allInvalidValues")
  )
  scalar_name <- "FA"


  for (i.config in seq_len(nrow(df.config))) {
    nsubj <- df.config$nsubj[i.config]
    specials <- df.config$specials[i.config]

    message(paste0("working on nsubj = ", toString(nsubj)))

    if (specials == "") {
      temp <- ""
    } else {
      temp <- paste0("_", specials)
    }
    fn.h5 <- system.file("extdata",
      paste0("n", toString(nsubj), "_voxels", temp, ".h5"),
      package = "ModelArray"
    )
    fn.expectedResults <- gsub(".h5", "_expectedResults.txt", fn.h5)
    fn.csv <- gsub(".h5", ".csv", fn.h5)


    modelarray <- ModelArray(fn.h5, scalar_types = scalar_name)
    phenotypes <- read.csv(fn.csv)
    expectedResults <- read.csv(fn.expectedResults)

    if (specials == "") { # specials=NULL
      ### default subj threshold #####

      ### ModelArray.lm()
      mylm <- ModelArray.lm(FA ~ age, modelarray, phenotypes, scalar = scalar_name, element.subset = NULL)
      expect_equal(
        check_as_expected(mylm, expectedResults),
        rep(TRUE, nrow(mylm))
      )

      mylm.fullOutputs <- ModelArray.lm(FA ~ age + sex, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        full.outputs = TRUE,
        correct.p.value.terms = c("fdr", "bonferroni"), correct.p.value.model = c("fdr", "bonferroni"),
        n_cores = 2
      )
      expect_equal(
        check_as_expected(mylm.fullOutputs, expectedResults),
        rep(TRUE, nrow(mylm.fullOutputs))
      )


      ### ModelArray.gam()
      mygam <- ModelArray.gam(FA ~ s(age) + sex, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        n_cores = 2
      )
      expect_equal(
        check_as_expected(mygam, expectedResults),
        rep(TRUE, nrow(mygam))
      )

      mygam.fullOutputs <- ModelArray.gam(FA ~ s(age) + sex, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        full.outputs = TRUE,
        correct.p.value.smoothTerms = c("fdr", "bonferroni"), correct.p.value.parametricTerms = c("fdr", "bonferroni"),
        n_cores = 2
      )
      expect_equal(
        check_as_expected(mygam.fullOutputs, expectedResults),
        rep(TRUE, nrow(mygam.fullOutputs))
      )

      mygam.changed.rsq <- ModelArray.gam(FA ~ s(age) + sex + factorA, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        changed.rsq.term.index = c(1),
        n_cores = 2
      )
      expect_equal(
        check_as_expected(mygam.changed.rsq, expectedResults),
        rep(TRUE, nrow(mygam.changed.rsq))
      )

      ### if threshold changes, expected results will also change, esp those around thr   #####
      # num.subj.lthr.abs
      mylm.changed.abs.thr <- ModelArray.lm(FA ~ age, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        num.subj.lthr.abs = 7,
        n_cores = 2
      )
      mygam.changed.abs.thr <- ModelArray.gam(FA ~ s(age), modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        num.subj.lthr.abs = 7,
        n_cores = 2
      )
      # num.subj.lthr.rel
      mylm.changed.rel.thr <- ModelArray.lm(FA ~ age, modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        num.subj.lthr.rel = 0.3,
        n_cores = 2
      )
      mygam.changed.rel.thr <- ModelArray.gam(FA ~ s(age), modelarray, phenotypes,
        scalar = scalar_name, element.subset = NULL,
        num.subj.lthr.rel = 0.3,
        n_cores = 2
      )

      if (nsubj == 60) {
        # with new abs.thr: does not affect it:
        expect_equal(
          check_as_expected(mylm.changed.abs.thr, expectedResults),
          rep(TRUE, nrow(mylm.changed.abs.thr))
        ) # still as expected, as 60*0.2 = 12 creating a higher bar
        expect_equal(
          check_as_expected(mygam.changed.abs.thr, expectedResults),
          rep(TRUE, nrow(mygam.changed.abs.thr))
        ) # still as expected, as 60*0.2 = 12 creating a higher bar

        # with new rel.thr: the num.subj.valid should > max(10, 0.3*60) = 18
        # for voxel #11-16:  # 1=sufficient, 0=insufficient   # see the .Rmd for generating the data
        # previous: 1,0,0,0,0,0
        # now:      0,0,0,0,0,0
        updated_temp <- c(
          rep(TRUE, 10), # TRUE: consistent with expectedResults saved in .txt; FALSE; inconsistent
          c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE),
          rep(TRUE, 4),
          rep(TRUE, nrow(mylm.changed.rel.thr) - 20)
        )
        expect_equal(
          check_as_expected(mylm.changed.rel.thr, expectedResults),
          updated_temp
        )
        expect_equal(
          check_as_expected(mygam.changed.rel.thr, expectedResults),
          updated_temp
        )
      } else if (nsubj == 40) {
        # with new abs thr, the num.subj.valid should > max(7,0.2*40) = 8
        # for voxel #11-16:     # 1=sufficient, 0=insufficient   # see the .Rmd for generating the data
        # previous: 1,0,0,1,0,0
        # now:      1,0,0,1,1,0
        updated_temp <- c(
          rep(TRUE, 10), # TRUE: consistent with expectedResults saved in .txt; FALSE; inconsistent
          c(TRUE, TRUE, TRUE, TRUE, FALSE, TRUE),
          rep(TRUE, 4),
          rep(TRUE, nrow(mylm.changed.abs.thr) - 20)
        )
        expect_equal(
          check_as_expected(mylm.changed.abs.thr, expectedResults),
          updated_temp
        )
        expect_equal(
          check_as_expected(mygam.changed.abs.thr, expectedResults),
          updated_temp
        )

        # with new rel thr, the num.subj.valid should > max(10, 0.3*40) = 12
        # for voxel #11-16:     # 1=sufficient, 0=insufficient   # see the .Rmd for generating the data
        # previous: 1,0,0,1,0,0
        # now:      0,0,0,0,0,0
        updated_temp <- c(
          rep(TRUE, 10), # TRUE: consistent with expectedResults saved in .txt; FALSE; inconsistent
          c(FALSE, TRUE, TRUE, FALSE, TRUE, TRUE),
          rep(TRUE, 4),
          rep(TRUE, nrow(mylm.changed.rel.thr) - 20)
        )
        expect_equal(
          check_as_expected(mylm.changed.rel.thr, expectedResults),
          updated_temp
        )
        expect_equal(
          check_as_expected(mygam.changed.rel.thr, expectedResults),
          updated_temp
        )
      }
    } else if (specials == "allInvalidValues") { # if all NaNs
      expect_error(ModelArray.lm(FA ~ age, modelarray, phenotypes, scalar = scalar_name, element.subset = NULL))
    }


    # TODO:

    # TODO: test the output messages are as expected
  }
})
